<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>变量、标识符、保留字、变量</title>
      <link href="/2023/01/11/java%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E3%80%81%E5%8F%98%E9%87%8F/"/>
      <url>/2023/01/11/java%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E3%80%81%E6%A0%87%E8%AF%86%E7%AC%A6%E3%80%81%E4%BF%9D%E7%95%99%E5%AD%97%E3%80%81%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="01、关键字与保留字"><a href="#01、关键字与保留字" class="headerlink" title="01、关键字与保留字"></a>01、关键字与保留字</h2><blockquote><p>1、关键字(keyword)的定义和特点</p></blockquote><ul><li>定义：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</li><li>特点：关键字中所有字母都为小写</li><li>官方地址： <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html</a></li></ul><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/b98175d8a9798669485b7532186d9f82.png" style="zoom: 67%;" /></p><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/b98175d8a9798669485b7532186d9f82.png" style="zoom:67%;" /></p><blockquote><p>2、保留字(reserved word)</p></blockquote><p>Java 保留字：现有 Java 版本尚未使用，但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字<code>goto、const</code>。</p><h2 id="02、标识符"><a href="#02、标识符" class="headerlink" title="02、标识符"></a>02、标识符</h2><h3 id="2-1、什么是标识符（Identifier）"><a href="#2-1、什么是标识符（Identifier）" class="headerlink" title="2.1、什么是标识符（Identifier）"></a>2.1、什么是标识符（Identifier）</h3><ul><li>Java 对各种变量、方法和类等要素命名时使用的字符序列称为标识符</li><li>技巧：凡是自己可以起名字的地方都叫标识符。</li></ul><h3 id="2-2、定义合法标识符规则【重要】"><a href="#2-2、定义合法标识符规则【重要】" class="headerlink" title="2.2、定义合法标识符规则【重要】"></a>2.2、定义合法标识符规则【重要】</h3><ol><li><strong>由 26 个英文字母大小写，0-9，_或$ 组成</strong></li><li><strong>数字不可以开头。</strong></li><li><strong>不可以使用关键字和保留字，但能包含关键字和保留字。</strong></li><li><strong>标识符不能包含空格。</strong></li><li><strong>Java 中严格区分大小写，长度无限制。</strong></li></ol><h3 id="2-3、Java-中的名称命名规范"><a href="#2-3、Java-中的名称命名规范" class="headerlink" title="2.3、Java 中的名称命名规范"></a>2.3、Java 中的名称命名规范</h3><blockquote><p>1、Java 中的名称命名规范：</p></blockquote><ul><li><strong>包名</strong>：多单词组成时<strong>所有字母都小写</strong>：xxxyyyzzz</li><li><strong>类名</strong>、接口名：多单词组成时，<strong>所有单词的首字母大写：</strong>XxxYyyZzz</li><li><p><strong>变量名</strong>、方法名：多单词组成时，<strong>第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</strong></p></li><li><p><strong>常量名</strong>：<strong>所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ</strong></p></li></ul><blockquote><p>2、注意点</p></blockquote><ul><li>注意 1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。</li><li>注意 2：java 采用 unicode 字符集，因此标识符也可以使用汉字声明，但是不建议使用。</li><li>更多细节详见《代码整洁之道》</li></ul><h2 id="03、变量"><a href="#03、变量" class="headerlink" title="03、变量"></a>03、变量</h2><h3 id="3-1、变量的声明与使用"><a href="#3-1、变量的声明与使用" class="headerlink" title="3.1、变量的声明与使用"></a>3.1、变量的声明与使用</h3><blockquote><p>1、变量的概念：</p></blockquote><ul><li>内存中的一个存储区域；\</li><li>该区域的数据可以在同一类型范围内不断变化；</li><li>变量是程序中最基本的存储单元。包含<strong>变量类型、变量名和存储的值。</strong></li></ul><blockquote><p>2、变量的作用：</p></blockquote><ul><li>用于在内存中保存数据。</li></ul><blockquote><p>3、使用变量注意：</p></blockquote><ul><li>Java 中每个变量必须先声明，后使用；</li><li>使用变量名来访问这块区域的数据；</li><li>变量的作用域：其定义所在的一对{ }内；</li><li>变量只有在其作用域内才有效；</li><li>同一个作用域内，不能定义重名的变量；</li></ul><blockquote><p>4、声明变量</p></blockquote><ul><li>语法：&lt;数据类型&gt; &lt;变量名称&gt;</li><li>例如：int var;</li></ul><blockquote><p>5、变量的赋值</p></blockquote><ul><li>语法：&lt;变量名称&gt; = &lt;值&gt;</li><li>例如：var = 10;</li></ul><blockquote><p>6、声明和赋值变量</p></blockquote><ul><li>语法：&lt;数据类型&gt;&lt;变量名&gt;= &lt;初始化值&gt;</li><li>例如：int var = 10</li></ul><blockquote><p>7、补充：变量的分类-按声明的位置的不同</p></blockquote><ul><li>在方法体外，类体内声明的变量称为<strong>成员变量</strong>。</li><li>在方法体内部声明的变量称为<strong>局部变量</strong>。</li></ul><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/58fa3b6eb659d69e11d281fb6a2364ea.png" style="zoom:67%;" /></p><blockquote><p>8、注意：二者在初始化值方面的异同:</p></blockquote><ul><li>同：都有生命周期</li><li>异：局部变量除形参外，需显式初始化。</li></ul><h3 id="3-2、基本数据类型"><a href="#3-2、基本数据类型" class="headerlink" title="3.2、基本数据类型"></a>3.2、基本数据类型</h3><blockquote><p>变量的分类-按数据类型</p></blockquote><p>对于每一种数据都定义了明确的具体数据类型（强类型语言），在内存中分配了不同大小的内存空间。</p><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/02a30584b81301520637d3b982d0bede.png" style="zoom:67%;" /></p><h4 id="3-2-1、整数类型：byte、short、int、long"><a href="#3-2-1、整数类型：byte、short、int、long" class="headerlink" title="3.2.1、整数类型：byte、short、int、long"></a>3.2.1、整数类型：byte、short、int、long</h4><ul><li>Java 各整数类型有固定的表数范围和字段长度，不受具体 OS 的影响，以保证 java 程序的可移植性。</li><li><strong>java 的整型常量默认为 int 型，声明 long 型常量须后加‘l’或‘L’</strong></li><li>java 程序中变量通常声明为 int 型，除非不足以表示较大的数，才使用 long</li></ul><div class="table-container"><table><thead><tr><th>类型</th><th>占用存储空间</th><th style="text-align:center">表数范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节=8bit位</td><td style="text-align:center">-128 ~ 127</td></tr><tr><td>short</td><td>2字节</td><td style="text-align:center">-2^15~ 2^15-1</td></tr><tr><td>int</td><td>4字节</td><td style="text-align:center">-2^31~ 2^31-1 (约21亿)</td></tr><tr><td>long</td><td>8字节</td><td style="text-align:center">-2^63~ 2^63-1</td></tr></tbody></table></div><ul><li>1MB = 1024KB 1KB= 1024B B= byte ? bit?</li><li><strong>bit: 计算机中的最小存储单位。byte:计算机中基本存储单元。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java定义的数据类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、变量按照数据类型来分：</span></span><br><span class="line"><span class="comment">基本数据类型：</span></span><br><span class="line"><span class="comment">整型：byte \ short \ int \ long</span></span><br><span class="line"><span class="comment">浮点型：float \ double</span></span><br><span class="line"><span class="comment">字符型：char</span></span><br><span class="line"><span class="comment">布尔型：boolean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用数据类型：</span></span><br><span class="line"><span class="comment">类：class</span></span><br><span class="line"><span class="comment">接口：interface</span></span><br><span class="line"><span class="comment">数组：array</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、变量在类中声明的位置：</span></span><br><span class="line"><span class="comment">成员变量 vs 局部变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest1</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//1. 整型：byte(1字节=8bit) short(2字节） \ int (4字节）\ long(8字节)</span></span><br><span class="line"><span class="comment">//① byte范围：-128 ~ 127</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line"><span class="comment">//b2 = 128; //编译不通过</span></span><br><span class="line">System.out.println(b1);</span><br><span class="line">System.out.println(b2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ② 声明long型变量，必须以“1”或“L”结尾</span></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">12345</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">345678586</span>;</span><br><span class="line">System.out.println(l1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2、浮点类型：float、double"><a href="#3-2-2、浮点类型：float、double" class="headerlink" title="3.2.2、浮点类型：float、double"></a>3.2.2、浮点类型：float、double</h4><ul><li>与整数类型类似，Java 浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</li><li>浮点型常量有两种表示形式：<ul><li>十进制数形式：如：5.12 512.0f .512 (必须有小数点）</li><li>科学计数法形式:如：5.12e2 512E2 100E-2</li></ul></li><li>float:单精度，尾数可以精确到7位有效数字。很多情况下，精度很难满足需求。</li><li>double:双精度，精度是float的两倍。通常采用此类型。</li><li><strong>Java 的浮点型常量默认为double型，声明float型常量，须后加‘f’或‘F’。</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th>占用存储空间</th><th>表数范围</th></tr></thead><tbody><tr><td style="text-align:center">单精度float</td><td>4字节</td><td>-3.403E38 ~ 3.403E38</td></tr><tr><td style="text-align:center">双精度double</td><td>8字节</td><td>-1.798E308 ~ 1.798E308</td></tr></tbody></table></div><h4 id="3-2-3、字符类型：char"><a href="#3-2-3、字符类型：char" class="headerlink" title="3.2.3、字符类型：char"></a>3.2.3、字符类型：char</h4><ul><li>char 型数据用来表示通常意义上“字符”(2字节)</li><li>Java中的所有字符都使用Unicode编码，故一个字符可以存储一个字母，一个汉字，或其他书面语的一个字符。</li><li>字符型变量的三种表现形式：<ul><li>字符常量是用单引号(‘ ’)括起来的单个字符。例如：char c1 = ‘a’; char c2 = ‘中’; char c3 = ‘9’;</li><li>Java中还允许使用转义字符‘\’来将其后的字符转变为特殊字符型常量。例如：char c3 = ‘\n’; //’\n’表示换行符</li><li>直接使用Unicode值来表示字符型常量：‘\uXXXX’。其中，XXXX代表一个十六进制整数。如：\u000a 表示\n。</li></ul></li><li>char类型是可以进行运算的。因为它都对应有Unicode码。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java定义的数据类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">一、变量按照数据类型来分：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">基本数据类型：</span></span><br><span class="line"><span class="comment">整型：byte \ short \ int \ long</span></span><br><span class="line"><span class="comment">浮点型：float \ double</span></span><br><span class="line"><span class="comment">字符型：char</span></span><br><span class="line"><span class="comment">布尔型：boolean</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">引用数据类型：</span></span><br><span class="line"><span class="comment">类：class</span></span><br><span class="line"><span class="comment">接口：interface</span></span><br><span class="line"><span class="comment">数组：array</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">二、变量在类中声明的位置：</span></span><br><span class="line"><span class="comment">成员变量 vs 局部变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest1</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//2. 浮点型：float(4字节) \ double(8字节)</span></span><br><span class="line"><span class="comment">//① 浮点型，表示带小数点的数值</span></span><br><span class="line"><span class="comment">//② float表示数值的范围比long还大</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.3</span>;</span><br><span class="line">System.out.println(d1 +<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义float类型变量时，变量要以&quot;f&quot; 或&quot;F&quot;结尾</span></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">12.3F</span>;</span><br><span class="line">System.out.println(f1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//② 通常，定义浮点型变量时，使用double变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 字符型：char(1字符=2字节)</span></span><br><span class="line"><span class="comment">//① 定义char型变量，通常使用一对&#x27;&#x27; </span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//c1 = &#x27;AB&#x27;;</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;&amp;&#x27;</span>;</span><br><span class="line">System.out.println(c2);</span><br><span class="line">System.out.println(c3);</span><br><span class="line">System.out.println(c4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//② 表示方式：1.声明一个字符；2.转义字符；3.直接使用Unicode值来表示字符型常量</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;<span class="comment">//换行符</span></span><br><span class="line">c5 = <span class="string">&#x27;\t&#x27;</span>;<span class="comment">//制表符</span></span><br><span class="line">System.out.print(<span class="string">&quot;hello&quot;</span> + c5);</span><br><span class="line">System.out.println(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c6</span> <span class="operator">=</span> <span class="string">&#x27;\u0123&#x27;</span>;</span><br><span class="line">System.out.println(c6);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="string">&#x27;\u0043&#x27;</span>;</span><br><span class="line">System.out.println(c7);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>了解：ASCII 码</p></blockquote><ul><li>在计算机内部，所有数据都使用二进制表示。每一个二进制位（bit）有0 和1 两种状态，因此8个二进制位就可以组合出256 种状态，这被称为一个字节（byte）。一个字节一共可以用来表示256 种不同的状态，每一个状态对应一个符号，就是256 个符号，从0000000 到11111111。</li><li>ASCII码：上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码。ASCII码一共规定了128个字符的编码，比如空格“SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。</li><li>缺点：<ul><li>不能表示所有字符。</li><li>相同的编码表示的字符不一样：比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel(ג)。</li></ul></li></ul><blockquote><p>了解：Unicode 编码</p></blockquote><ul><li>乱码：世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。</li><li>Unicode：一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，使用Unicode 没有乱码的问题。</li><li>Unicode 的缺点：Unicode 只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储：无法区别Unicode 和ASCII：计算机无法区分三个字节表示一个符号还是分别表示三个符号。另外，我们知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费。</li></ul><blockquote><p>了解：UTF-8</p></blockquote><ul><li>UTF-8 是在互联网上使用最广的一种Unicode 的实现方式。</li><li>UTF-8 是一种变长的编码方式。它可以使用1-6 个字节表示一个符号，根据不同的符号而变化字节长度。</li><li>UTF-8的编码规则：<ul><li>对于单字节的UTF-8编码，该字节的最高位为0，其余7位用来对字符进行编码（等同于ASCII码）。</li><li>对于多字节的UTF-8编码，如果编码包含n 个字节，那么第一个字节的前n位为1，第一个字节的第n+1 位为0，该字节的剩余各位用来对字符进行编码。在第一个字节之后的所有的字节，都是最高两位为”10”，其余6位用来对字符进行编码。</li></ul></li></ul><h4 id="3-3-4、布尔类型：boolean"><a href="#3-3-4、布尔类型：boolean" class="headerlink" title="3.3.4、布尔类型：boolean"></a>3.3.4、<a href="https://so.csdn.net/so/search?q=布尔类型&amp;spm=1001.2101.3001.7020">布尔类型</a>：boolean</h4><ul><li>boolean 类型用来判断逻辑条件，一般用于程序流程控制：<ul><li>if条件控制语句；</li><li>while循环控制语句；</li><li>do-while循环控制语句；</li><li>for循环控制语句；</li></ul></li><li>boolean类型数据只允许取值true和false，无null。<ul><li>不可以使用0或非0 的整数替代false和true，这点和C语言不同。</li><li>Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达所操作的boolean值，在编译之后都使用java虚拟机中的int数据类型来代替：true用1表示，false用0表示。———《java虚拟机规范8版》</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest1</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//4. 布尔型：boolean</span></span><br><span class="line"><span class="comment">//① 只能取两个值之一：true 、false</span></span><br><span class="line"><span class="comment">//② 常常在条件判断、循环结构中使用</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">bb1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(bb1);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(isMarried)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;禁止入内！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;可以参观！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3、基本数据类型转换"><a href="#3-3、基本数据类型转换" class="headerlink" title="3.3、基本数据类型转换"></a>3.3、基本数据类型转换</h3><ul><li>自动类型转换：容量小的类型自动转换为容量大的数据类型。数据类型按容量大小排序为：<br><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/5f55de57c32a87d59ef581f39d0a92e6.png" style="zoom:67%;" /></li><li>有多种类型的数据混合运算时，系统首先自动将所有数据转换成容量最大的那种数据类型，然后再进行计算。</li><li><strong>byte,short,char之间不会相互转换，他们三者在计算时首先转换为int类型</strong>。</li><li><strong>boolean类型不能与其它数据类型运算</strong>。</li><li><strong>当把任何基本数据类型的值和字符串(String)进行连接运算时(+)，基本数据类型的值将自动转化为字符串(String)类型</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本数据类型之间的运算规则：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">前提：这里讨论只是7中基本数据类型变量的运算。不包含boolean类型的。</span></span><br><span class="line"><span class="comment">1. 自动类型提升：</span></span><br><span class="line"><span class="comment">当容量小的数据类型的变量和容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。</span></span><br><span class="line"><span class="comment">char、byte、short--&gt;int--&gt;long--&gt;float--&gt;double</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">特别的：当byte、char、short三种类型的变量做运算时，结果为int类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 强制类型转换：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：此时容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"><span class="comment">//编译不通过</span></span><br><span class="line"><span class="comment">//byte b2 = b1 + i1;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">System.out.println(i2);</span><br><span class="line">System.out.println(l1);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">System.out.println(f);</span><br><span class="line"><span class="comment">//***************特别的**************************</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//97</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> c1 + i3;</span><br><span class="line">System.out.println(i4);</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"><span class="comment">//char c3 = c1 + s2;</span></span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//char c3 = c1 + b2;//编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//short s3 = b2 + s2;//编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//short s4 = b1 + b2;//编译不通过</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest4</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//1. 编码情况</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line">System.out.println(l);</span><br><span class="line"><span class="comment">//编译失败：过大的整数</span></span><br><span class="line"><span class="comment">//long l1 = 452367894586235;</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">452367894586235L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//**************************</span></span><br><span class="line"><span class="comment">//编译失败</span></span><br><span class="line"><span class="comment">//float f1 = 12.3;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 编码情况2:</span></span><br><span class="line"><span class="comment">//整型变量，默认类型为int型</span></span><br><span class="line"><span class="comment">//浮点型变量，默认类型为double型</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="comment">//byte b1 = b + 1;//编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//float f1 = b + 12.3;//编译失败</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-3、字符串类型：String"><a href="#3-3、字符串类型：String" class="headerlink" title="3.3、字符串类型：String"></a>3.3、字符串类型：String</h3><ul><li><strong>String不是基本数据类型，属于引用数据类型</strong></li><li>使用方式与基本数据类型一致。例如：String str= “abcd”;</li><li>一个字符串可以串接另一个字符串，也可以直接串接其他类型的数据。例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">String类型变量的使用</span></span><br><span class="line"><span class="comment">1. String属于引用数据类型</span></span><br><span class="line"><span class="comment">2. 声明String类型变量时，使用一对&quot;&quot;</span></span><br><span class="line"><span class="comment">3. String可以和8种基本数据类型变量做运算，且运算只能是连接运算；+</span></span><br><span class="line"><span class="comment">4. 运算的结果任然是String类型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Good Moon!&quot;</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(s1);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char c = &#x27;&#x27;;//编译不通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*******************************</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">numberStr</span> <span class="operator">=</span> <span class="string">&quot;学号:&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> numberStr + number;<span class="comment">//连接运算</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">info1</span> <span class="operator">=</span> info + <span class="literal">true</span>;</span><br><span class="line">System.out.println(info1);  <span class="comment">//结果：学号:1001true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="04、进制"><a href="#04、进制" class="headerlink" title="04、进制"></a>04、进制</h2><h3 id="4-1、进制与进制间的转换"><a href="#4-1、进制与进制间的转换" class="headerlink" title="4.1、进制与进制间的转换"></a>4.1、进制与进制间的转换</h3><blockquote><p>关于进制</p></blockquote><ul><li>所有数字在计算机底层都以二进制形式存在。</li><li>对于整数，有四种表示方式：<ul><li>二进制(binary)：0,1 ，满2进1.以<code>0b</code>或<code>0B</code>开头。</li><li>十进制(decimal)：0-9 ，满10进1。</li><li>八进制(octal)：0-7 ，满8进1. 以数字<code>0</code>开头表示。</li><li>十六进制(hex)：0-9及A-F，满16进1. 以<code>0x</code>或<code>0X</code>开头表示。此处的A-F不区分大小写。如：0x21AF +1= 0X21B0</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0b110</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">0127</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">0x110A</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1);</span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span> + num2);</span><br><span class="line">System.out.println(<span class="string">&quot;num3 = &quot;</span> + num3);</span><br><span class="line">System.out.println(<span class="string">&quot;num4 = &quot;</span> + num4);  </span><br><span class="line">        <span class="comment">/*num1 = 6</span></span><br><span class="line"><span class="comment">          num2 = 110</span></span><br><span class="line"><span class="comment">          num3 = 87</span></span><br><span class="line"><span class="comment">  num4 = 4362*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2、二进制"><a href="#4-2、二进制" class="headerlink" title="4.2、二进制"></a>4.2、二进制</h3><ul><li><p>Java整数常量默认是int类型，当用二进制定义整数时，其第32位是符号位；当是long类型时，二进制默认占64位，第64位是符号位</p></li><li><p>二进制的整数有如下三种形式：</p><ul><li>原码：直接将一个数值换成二进制数。最高位是符号位</li><li>负数的<strong>反码</strong>：是对<strong>原码按位取反，只是最高位（符号位）确定为1</strong>。</li><li>负数的<strong>补码</strong>：其<strong>反码加1</strong>。计算机以二进制补码的形式保存所有的整数。</li><li>正数的原码、反码、补码都相同，负数的补码是其反码+1</li></ul></li></ul><blockquote><p>为什么要使用原码、反码、补码表示形式呢？</p></blockquote><p>计算机辨别“符号位”显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了。</p><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/7775c47e49965529b779183a44e41fb9.png" style="zoom:67%;" /></p><p><strong>二进制——&gt;十进制</strong></p><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/c2d9860f3b822dbeabac4b4ff6e0c7c5.png" style="zoom:67%;" /></p><blockquote><p><strong>原码与反码是帮助推导出补码而存在的！！！</strong></p></blockquote><p><strong>十进制——&gt;二进制</strong></p><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/a200a439100aaa2c2721deb5c8664693.png" style="zoom:67%;" /></p><ul><li>对于正数来讲：原码、反码、补码是相同的：三码合一。</li><li>计算机底层都是使用二进制表示的数值。</li><li><strong>计算机底层都是使用的数值的<code>补码</code>保存数据的。</strong></li></ul><h3 id="4-3、进制间转化"><a href="#4-3、进制间转化" class="headerlink" title="4.3、进制间转化"></a>4.3、进制间转化</h3><blockquote><p>十进制二进制互转</p></blockquote><ul><li>二进制转成十进制乘以2的幂数</li><li>十进制转成二进制除以2取余数</li></ul><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/050e3f2cd04de75da6e70a074670260d.png" style="zoom:67%;" /></p><p><img src="https://cx330-cc.oss-cn-hangzhou.aliyuncs.com/img/b3386e2cd8b7990a222895f6b0472d33.png" style="zoom:67%;" /></p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/2022/12/18/leetcode01/"/>
      <url>/2022/12/18/leetcode01/</url>
      
        <content type="html"><![CDATA[<h1 id="leetcode算法"><a href="#leetcode算法" class="headerlink" title="leetcode算法"></a>leetcode算法</h1><h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回</p><p>它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p> <strong>示例 1：</strong></p><p>输入：nums = [2,7,11,15], target = 9</p><p>输出：[0,1]</p><p>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p><p> <strong>示例 2：</strong></p><p> 输入：nums = [3,2,4], target = 6</p><p>输出：[1,2]</p><p> <strong>示例 3：</strong></p><p> 输入：nums = [3,3], target = 6</p><p>输出：[0,1]</p><h3 id="暴力枚举："><a href="#暴力枚举：" class="headerlink" title="暴力枚举："></a>暴力枚举：</h3><p><strong>思路及算法：</strong></p><p> 枚举数组的每一个数x，寻找数组中是否存在target-x。</p><p>当我们使用遍历整个数组的方式 寻找target-x时，需要注意每一个位于x之前的元素都和x匹配过，因此不    </p><p>需要进行匹配。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="哈希表："><a href="#哈希表：" class="headerlink" title="哈希表："></a><strong>哈希表：</strong></h3><p><strong>思路及算法：</strong></p><p>使用哈希表，可以将寻找target-x的时间复杂度降低到从O（N）降低到O（1）。</p><p>我们先创建一个哈希表，对于每一个x，我们首先查询哈希表是否存在target-x，然后将x插入到哈希表，即</p><p>保证不会让x和自己匹配。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; hashtable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();  <span class="comment">//建立哈希表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="comment">// 查询哈希表中是否存在target-x</span></span><br><span class="line">            <span class="keyword">if</span> (hashtable.containsKey(target - nums[i])) &#123;    </span><br><span class="line">               <span class="comment">//若存在则返回俩数的下标</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;hashtable.get(target - nums[i]), i&#125;; </span><br><span class="line">            &#125;</span><br><span class="line">            hashtable.put(nums[i], i);   <span class="comment">//否则将这组数和下标添加到哈希表中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇</title>
      <link href="/2022/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/18/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>第二篇</title>
      <link href="/2022/12/18/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/12/18/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇文章"><a href="#第二篇文章" class="headerlink" title="第二篇文章"></a>第二篇文章</h2><hr><p><strong>NOTE</strong></p><p>It works with almost all markdown flavours (the below blank line matters).</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>算法2</title>
      <link href="/2022/12/18/LeetCode/"/>
      <url>/2022/12/18/LeetCode/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h1><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="搜索旋转排序数组（LC33）"><a href="#搜索旋转排序数组（LC33）" class="headerlink" title="搜索旋转排序数组（LC33）"></a>搜索旋转排序数组（LC33）</h3><h4 id="题目详情："><a href="#题目详情：" class="headerlink" title="题目详情："></a><strong>题目详情：</strong></h4><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, </p><p>nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 </p><p>[4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。</p><p>示例 1：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 0</p><p>输出：4</p><p>示例 2：</p><p>输入：nums = [4,5,6,7,0,1,2], target = 3</p><p>输出：-1</p><p>示例 3：</p><p>输入：nums = [1], target = 0</p><p>输出：-1</p><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 5000-10^4 &lt;= nums[i] &lt;= 10^4nums 中的每个值都 独一无二题目数据保证 nums 在预先未知的某个下标上进行了旋转-10^4 &lt;= target &lt;= 10^4</code></pre><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, </p><p>6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。</p><p>我们可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有</p><p>序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分：</p><pre><code>如果 [l, mid - 1] 是有序数组，且 target 的大小满足 [nums[l],nums[mid])，则我们应该将搜索范围缩小至 [l, mid - 1]，否则在 [mid + 1, r] 中寻找。如果 [mid, r] 是有序数组，且 target 的大小满足 (nums[mid+1],nums[r]]，则我们应该将搜索范围缩小至 [mid + 1, r]，否则在 [l, mid - 1] 中寻找。</code></pre><p><strong>算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[<span class="number">0</span>] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[n - <span class="number">1</span>]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度： O(log⁡n)，其中 n为 nums 数组的大小。整个算法时间复杂度即为二分查找的</p><p>​                        时间复杂度 O(log⁡n)</p><p>空间复杂度： O(1) 。我们只需要常数级别的空间存放变量。</p><h4 id="方法二（朴素解法）"><a href="#方法二（朴素解法）" class="headerlink" title="方法二（朴素解法）"></a>方法二（朴素解法）</h4><p><strong>思路：</strong></p><p>但凡是从有序序列中找某个数，我们第一反应应该是「二分」。</p><p>这道题是一个原本有序的数组在某个点上进行了旋转，其实就是将原本一段升序的数组分为了两段。</p><p>我们可以先找到旋转点 idx，然后对 idx 前后进行「二分」。</p><p><strong>算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> find(nums, <span class="number">0</span>, idx, target);</span><br><span class="line">        <span class="keyword">if</span> (ans != -<span class="number">1</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (idx + <span class="number">1</span> &lt; n) ans = find(nums, idx + <span class="number">1</span>, n - <span class="number">1</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l] == target ? l : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：先对数组进行一次遍历，找到 idx，复杂度为 O(n)，对 idx 前后进行二分查找，复杂度为 </p><p>​                        O(log⁡n)。整体为 O(n)</p><p>空间复杂度：O(1)</p><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p><strong>思路：</strong></p><p>不难发现，虽然在朴素解法中我们应用了「二分」查找。</p><p>但理论复杂度为 O(n)O(n)O(n)，实际复杂度也远达不到 O(log⁡n)O(\log{n})O(logn)，执行效率取决于旋转点 idx 所在数组的下标位</p><p>置。</p><p>那么我们如何实现 O(log⁡n)O(\log{n})O(logn) 的解法呢？</p><p>这道题其实是要我们明确「二分」的本质是什么。</p><p>「二分」不是单纯指从有序数组中快速找某个数，这只是「二分」的一个应用。</p><p>「二分」的本质是两段性，并非单调性。只要一段满足某个性质，另外一段不满足某个性质，就可以用「二分」。</p><p>经过旋转的数组，显然前半段满足 &gt;= nums[0]，而后半段不满足 &gt;= nums[0]。我们可以以此作为依据，通过「二分」找到旋转点。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>] == target ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一次「二分」：从中间开始找，找到满足 &gt;=nums[0] 的分割点（旋转点）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//当出现l=mid这种条件时，mid赋值就要加1表示上取整，因为当只剩下两个元素的时候，不上取整会出现死循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>; </span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                l = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二次「二分」：通过和 nums[0] 进行比较，得知 target 是在旋转点的左边还是右边</span></span><br><span class="line">        <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = l + <span class="number">1</span>;</span><br><span class="line">            r = n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[r] == target ? r : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li>时间复杂度：O(log⁡n)</li><li>空间复杂度：O(1)</li></ul><h3 id="在排序数组中查找元素的第一个和最后一个位置（LC34）"><a href="#在排序数组中查找元素的第一个和最后一个位置（LC34）" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置（LC34）"></a>在排序数组中查找元素的第一个和最后一个位置（LC34）</h3><h4 id="题目详情：-1"><a href="#题目详情：-1" class="headerlink" title="题目详情："></a>题目详情：</h4><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>进阶：</p><pre><code>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</code></pre><p>示例 1：</p><p>输入：nums = [5,7,7,8,8,10], target = 8</p><p>输出：[3,4]</p><p>示例 2：</p><p>输入：nums = [5,7,7,8,8,10], target = 6</p><p>输出：[-1,-1]</p><p>示例 3：</p><p>输入：nums = [], target = 0</p><p>输出：[-1,-1]</p><p>提示：</p><pre><code>0 &lt;= nums.length &lt;= 105-109 &lt;= nums[i] &lt;= 109nums 是一个非递减数组-109 &lt;= target &lt;= 109</code></pre><h4 id="方法一-1"><a href="#方法一-1" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>由于数组已经排序，因此整个数组是单调递增的，我们可以利用二分法来加速查找的过程。</p><p>考虑 target 开始和结束位置，其实我们要找的就是数组中「第一个等于 target 的位置」（记为 leftIdx）和「第</p><p>一个大于 target 的位置减一」（记为 rightIdx）。</p><p>二分查找中，寻找 leftIdx 即为在数组中寻找第一个大于等于 target 的下标，寻找 rightIdx 即为在数组中寻找第</p><p>一个大于 target 的下标，然后将下标减一。两者的判断条件不同，为了代码的复用，我们定义 binarySearch(nums, target, lower) </p><p>表示在 nums 数组中二分查找 target的位置，如果 lower为 true，则查找第一个大于等于 target的下标，否则查找第一个大于 </p><p>target的下标。</p><p>最后，因为 target可能不存在数组中，因此我们需要重新校验我们得到的两个下标 leftIdx和 rightIdx，看是否</p><p>符合条件，如果符合条件就返回[leftIdx,rightIdx]，不符合就返回[−1,−1]。</p><p><strong>算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightIdx</span> <span class="operator">=</span> binarySearch(nums, target, <span class="literal">false</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (leftIdx &lt;= rightIdx &amp;&amp; rightIdx &lt; nums.length &amp;&amp; nums[leftIdx] == target &amp;&amp; nums[rightIdx] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftIdx, rightIdx&#125;;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> lower)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>, ans = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度： O(log⁡n)，其中 n 为数组的长度。二分查找的时间复杂度为 O(log⁡n)，一共会执行两次，因此总时间复杂度为 O(log⁡n)。</p><p>空间复杂度：O(1) 。只需要常数空间存放若干变量。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p><strong>思路：</strong></p><p>「二分」有一个比较容易混淆的点是：当需要找目标值第一次出现的下标时，条件应该写成 nums[mid]&gt;=target还是 nums[mid]</p><p>&lt;=target。</p><p>其实有一个很好理解的方法：</p><p>由于二分是从中间开始找起的，所以找的必然是条件区间中靠近中心的的边界值。</p><p>文字不好理解，我们结合图片来看：</p><p><img src="LeetCode.assets/01.png" style="zoom:50%;" /></p><p><strong>算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans[<span class="number">0</span>] = l;</span><br><span class="line">            l = <span class="number">0</span>; r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                    l = mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            ans[<span class="number">1</span>] = l;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法度分析：</strong></p><ul><li>时间复杂度：O(log⁡n)</li><li>空间复杂度：O(1)</li></ul><h3 id="搜索插入位置（LC35）"><a href="#搜索插入位置（LC35）" class="headerlink" title="搜索插入位置（LC35）"></a>搜索插入位置（LC35）</h3><h4 id="题目详情：-2"><a href="#题目详情：-2" class="headerlink" title="题目详情："></a>题目详情：</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位</p><p>置。</p><p>你可以假设数组中无重复元素。</p><p>示例 1:</p><p>输入: [1,3,5,6], 5</p><p>输出: 2</p><p>示例 2:</p><p>输入: [1,3,5,6], 2</p><p>输出: 1</p><p>示例 3:</p><p>输入: [1,3,5,6], 7</p><p>输出: 4</p><p>示例 4:</p><p>输入: [1,3,5,6], 0</p><p>输出: 0</p><h4 id="方法一-2"><a href="#方法一-2" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>考虑这个插入的位置 pos，它成立的条件为：</p><p>nums[pos−1]&lt;target≤nums[pos]</p><p>其中 nums代表排序数组。由于如果存在这个目标值，我们返回的索引也是 pos，因此我们可以将两个条件合并得出最后的目标：</p><p>「在一个有序数组中找第一个大于等于 target 的下标」。</p><p>问题转化到这里，直接套用二分法即可，即不断用二分法逼近查找第一个大于等于 target的下标 。</p><p><strong>算法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>, ans = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid]) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：O(log⁡n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log⁡n)。</p><p>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p><h4 id="方法二-1"><a href="#方法二-1" class="headerlink" title="方法二"></a>方法二</h4><p><strong>思路：</strong></p><p>特殊情况：如果目标元素大于输入数组中的最后一个元素，返回数组的最后一个元素的下标 + 1。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 特殊判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &lt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 程序走到这里一定有 target &lt;= nums[len - 1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 在区间 nums[left..right] 里查找第 1 个大于等于 target 的元素的下标</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [mid + 1..right]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间是 [left..mid]</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法度分析：</strong></p><p>时间复杂度：O(log⁡n)，其中 n 为数组的长度。二分查找所需的时间复杂度为 O(log⁡n)。</p><p>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p><h4 id="方法三-1"><a href="#方法三-1" class="headerlink" title="方法三"></a>方法三</h4><p><strong>思路：</strong></p><p>每次根据 nums[mid] 和 target 之间的大小进行判断，相等则直接返回下标，nums[mid] &lt; target 则 left 右移，nums[mid] &gt; target </p><p>则 right 左移</p><p>查找结束如果没有相等值则返回 left，该值为插入位置</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯法："><a href="#回溯法：" class="headerlink" title="回溯法："></a>回溯法：</h2><h3 id="电话号码的字母组合（LC17）"><a href="#电话号码的字母组合（LC17）" class="headerlink" title="电话号码的字母组合（LC17）"></a>电话号码的字母组合（LC17）</h3><h4 id="题目详情：-3"><a href="#题目详情：-3" class="headerlink" title="题目详情："></a>题目详情：</h4><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="LeetCode.assets/02.PNG" style="zoom:50%;" /></p><p>示例 1：</p><p>输入：digits = “23”</p><p>输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]</p><p>示例 2：</p><p>输入：digits = “”</p><p>输出：[]</p><p>示例 3：</p><p>输入：digits = “2”</p><p>输出：[“a”,”b”,”c”]</p><h4 id="方法一-3"><a href="#方法一-3" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><p>回溯过程中维护一个字符串，表示已有的字母排列（如果未遍历完电话号码的所有数字，则已有的字母排列是不完整的）。该字符串</p><p>初始为空。每次取电话号码的一位数字，从哈希表中获得该数字对应的所有可能的字母，并将其中的一个字母插入到已有的字母排列</p><p>后面，然后继续处理电话号码的后一位数字，直到处理完电话号码中的所有数字，即得到一个完整的字母排列。然后进行回退操作，</p><p>遍历其余的字母排列。</p><p>回溯算法用于寻找所有的可行解，如果发现一个解不可行，则会舍弃不可行的解。在这道题中，由于每个数字对应的每个字母都可能</p><p>进入字母组合，因此不存在不可行的解，直接穷举所有的解即可。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (digits.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> combinations;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Character, String&gt; phoneMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, String&gt;() &#123;&#123;</span><br><span class="line">            put(<span class="string">&#x27;2&#x27;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;3&#x27;</span>, <span class="string">&quot;def&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;4&#x27;</span>, <span class="string">&quot;ghi&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;5&#x27;</span>, <span class="string">&quot;jkl&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;6&#x27;</span>, <span class="string">&quot;mno&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;7&#x27;</span>, <span class="string">&quot;pqrs&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;8&#x27;</span>, <span class="string">&quot;tuv&quot;</span>);</span><br><span class="line">            put(<span class="string">&#x27;9&#x27;</span>, <span class="string">&quot;wxyz&quot;</span>);</span><br><span class="line">        &#125;&#125;;</span><br><span class="line">        backtrack(combinations, phoneMap, digits, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">StringBuffer</span>());</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; combinations, Map&lt;Character, String&gt; phoneMap, String digits, <span class="type">int</span> index, StringBuffer combination)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == digits.length()) &#123;</span><br><span class="line">            combinations.add(combination.toString());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">digit</span> <span class="operator">=</span> digits.charAt(index);</span><br><span class="line">            <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> phoneMap.get(digit);</span><br><span class="line">            <span class="type">int</span> <span class="variable">lettersCount</span> <span class="operator">=</span> letters.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lettersCount; i++) &#123;</span><br><span class="line">                combination.append(letters.charAt(i));</span><br><span class="line">                backtrack(combinations, phoneMap, digits, index + <span class="number">1</span>, combination);</span><br><span class="line">                combination.deleteCharAt(index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度：O( 3<sup>m</sup>*4<sup>n</sup>)，其中 m 是输入中对应 3 个字母的数字个数（包括数字 2、3、</p><p>4、5、6、8），n 是输入中对应 4个字母的数字个数（包括数字 7、9），m+n 是输入数字的总个</p><p>数。当输入包含 m 个对应 3 个字母的数字和 n 个对应4 个字母的数字时，不同的字母组合一共有 3<sup>m</sup>*4<sup>n</sup>种，需要遍历</p><p>每一种字母组合。</p><p>空间复杂度：O(m+n)，其中 m 是输入中对应 3个字母的数字个数，n 是输入中对应 4 个字母的数字个</p><p>数，m+n 是输入数字的总个数。除了返回值以外，空间复杂度主要取决于哈希表以及回溯过程中的递归调用层数，哈希表</p><p>的大小与输入无关，可以看成常数，递归调用层数最大为 m+n。</p><h4 id="方法二-2"><a href="#方法二-2" class="headerlink" title="方法二"></a>方法二</h4><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;...</span></span><br><span class="line"><span class="comment">//这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">String[] letter_map = &#123;<span class="string">&quot; &quot;</span>,<span class="string">&quot; &quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line"><span class="comment">//注意边界条件</span></span><br><span class="line"><span class="keyword">if</span>(digits==<span class="literal">null</span> || digits.length()==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line">iterStr(digits, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终输出结果的list</span></span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归函数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">iterStr</span><span class="params">(String str, StringBuilder letter, <span class="type">int</span> index)</span> &#123;</span><br><span class="line"><span class="comment">//递归的终止条件</span></span><br><span class="line"><span class="comment">//用index记录每次遍历到字符串的位置</span></span><br><span class="line"><span class="keyword">if</span>(index == str.length()) &#123;</span><br><span class="line">res.add(letter.toString());</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取index位置的字符，假设输入的字符是&quot;234&quot;</span></span><br><span class="line"><span class="comment">//第一次递归时index为0所以c=2，第二次index为1所以c=3，第三次c=4</span></span><br><span class="line"><span class="comment">//subString每次都会生成新的字符串，而index则是取当前的一个字符，所以效率更高一点</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> str.charAt(index);</span><br><span class="line"><span class="comment">//map_string的下表是从0开始一直到9， c-&#x27;0&#x27;就可以取到相对的数组下标位置</span></span><br><span class="line"><span class="comment">//比如c=2时候，2-&#x27;0&#x27;，获取下标为2,letter_map[2]就是&quot;abc&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">map_string</span> <span class="operator">=</span> letter_map[pos];</span><br><span class="line"><span class="comment">//遍历字符串，比如第一次得到的是2，页就是遍历&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;map_string.length();i++) &#123;</span><br><span class="line"><span class="comment">//调用下一层递归</span></span><br><span class="line">            letter.append(map_string.charAt(i));</span><br><span class="line">            <span class="comment">//如果是String类型做拼接效率会比较低</span></span><br><span class="line"><span class="comment">//iterStr(str, letter+map_string.charAt(i), index+1);</span></span><br><span class="line">            iterStr(str, letter, index+<span class="number">1</span>);</span><br><span class="line">            letter.deleteCharAt(letter.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三-2"><a href="#方法三-2" class="headerlink" title="方法三"></a>方法三</h4><p><strong>思路：</strong></p><p>我们可以利用队列的先进先出特点，再配合循环完成题目要求。</p><p>我们先将2对应的字符”a”,”b”,”c”依次放入队列中</p><p><img src="LeetCode.assets/5d331f111c4bc5439116bc412a57e1271f0e1997b1328009cedce5152bce292f-%E9%98%9F%E5%88%97-1.jpg" style="zoom:50%;" /></p><p>之后再从队列中拿出第一个元素”a”，跟3对应的字符”d”,”e”,”f”挨个拼接</p><p><img src="LeetCode.assets/18b4155eb5122b9e177a29c7320de89048b74cc5553632700a45e07aa92057bc-%E9%98%9F%E5%88%97-1.jpg" style="zoom:50%;" /></p><p>于是队列就变成了下面这个样子：</p><p><img src="LeetCode.assets/89f52c9185b736edec7e980db7cf1a9897d5efbf1e80e1d19296ee48917fdfb9-%E9%98%9F%E5%88%97-3.jpg" style="zoom:50%;" /></p><p>按照同样的方式，再将”b”从队列中拿出，再跟3对应的字符”d”,”e”,”f”挨个拼接，队列又变成下面这个样子：</p><p><img src="LeetCode.assets/7fbe1e06dc207dbc539c7f580698eaad845ae5ff913b1b048211355a72fb3bcb-%E9%98%9F%E5%88%97-4-16283865557803.jpg" style="zoom:50%;" /></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(digits==<span class="literal">null</span> || digits.length()==<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个映射表，第二个位置是&quot;abc“,第三个位置是&quot;def&quot;。。。</span></span><br><span class="line"><span class="comment">//这里也可以用map，用数组可以更节省点内存</span></span><br><span class="line">String[] letter_map = &#123;</span><br><span class="line"><span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//先往队列中加入一个空字符</span></span><br><span class="line">res.add(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;digits.length();i++) &#123;</span><br><span class="line"><span class="comment">//由当前遍历到的字符，取字典表中查找对应的字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> letter_map[digits.charAt(i)-<span class="string">&#x27;0&#x27;</span>];</span><br><span class="line"><span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> res.size();</span><br><span class="line"><span class="comment">//计算出队列长度后，将队列中的每个元素挨个拿出来</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;size;j++) &#123;</span><br><span class="line"><span class="comment">//每次都从队列中拿出第一个元素</span></span><br><span class="line"><span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> res.remove(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//然后跟&quot;def&quot;这样的字符串拼接，并再次放到队列中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;letters.length();k++) &#123;</span><br><span class="line">res.add(tmp+letters.charAt(k));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号生成（LC22）"><a href="#括号生成（LC22）" class="headerlink" title="括号生成（LC22）"></a>括号生成（LC22）</h3><h4 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h4><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。</p><p>示例 1：</p><p>输入：n = 3</p><p>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p><p>示例 2：</p><p>输入：n = 1</p><p>输出：[“()”]</p><p>提示：</p><pre><code>1 &lt;= n &lt;= 8</code></pre><h4 id="方法一（暴力解法）"><a href="#方法一（暴力解法）" class="headerlink" title="方法一（暴力解法）"></a>方法一（暴力解法）</h4><p><strong>思路：</strong></p><p>我们可以生成所有2<sup>2n</sup> 个 ‘(‘ 和 ‘)’ 字符构成的序列，然后我们检查每一个是否有效即可。</p><p>为了生成所有序列，我们可以使用递归。长度为 n 的序列就是在长度为 n-1 的序列前加一个 ‘(‘ 或 ‘)’。</p><p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 balance 表示左括号的数量减去右括号的数量。如果在遍历过程中 </p><p>balance 的值小于零，或者结束时 balance 的值不为零，那么该序列就是无效的，否则它是有效的。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        generateAll(<span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">2</span> * n], <span class="number">0</span>, combinations);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateAll</span><span class="params">(<span class="type">char</span>[] current, <span class="type">int</span> pos, List&lt;String&gt; result)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == current.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(current)) &#123;</span><br><span class="line">                result.add(<span class="keyword">new</span> <span class="title class_">String</span>(current));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current[pos] = <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            generateAll(current, pos + <span class="number">1</span>, result);</span><br><span class="line">            current[pos] = <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            generateAll(current, pos + <span class="number">1</span>, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">valid</span><span class="params">(<span class="type">char</span>[] current)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">balance</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c: current) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ++balance;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                --balance;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (balance &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> balance == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：O(2<sup>2n</sup>n)，对于 2<sup>2n</sup> 个序列中的每一个，我们用于建立和验证该序列的复杂度为 </p><p>O(n)。</p></li><li><p>空间复杂度：O(n），除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 O(1)的空间，最多递归 2n 层，因此空间复杂度为 O(n)。</p></li></ul><h4 id="方法二-3"><a href="#方法二-3" class="headerlink" title="方法二"></a>方法二</h4><p><strong>思路：</strong></p><p>方法一还有改进的余地：我们可以只在序列仍然保持有效时才添加 ‘(‘ or ‘)’，而不是像 方法一 那样每次添加。我们可以通过跟踪到目</p><p>前为止放置的左括号和右括号的数目来做到这一点，</p><p>如果左括号数量不大于 n，我们可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        backtrack(ans, <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(List&lt;String&gt; ans, StringBuilder cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.length() == max * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.add(cur.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; max) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open + <span class="number">1</span>, close, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.append(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            backtrack(ans, cur, open, close + <span class="number">1</span>, max);</span><br><span class="line">            cur.deleteCharAt(cur.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三（深度优先遍历）"><a href="#方法三（深度优先遍历）" class="headerlink" title="方法三（深度优先遍历）"></a>方法三（深度优先遍历）</h4><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 做减法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//特判</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行深度优先遍历，搜索可能的结果</span></span><br><span class="line">        dfs(<span class="string">&quot;&quot;</span>, n, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curStr 当前递归得到的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left   左括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right  右括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res    结果集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String curStr, <span class="type">int</span> left, <span class="type">int</span> right, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 因为每一次尝试，都使用新的字符串变量，所以无需回溯</span></span><br><span class="line">        <span class="comment">// 在递归终止的时候，直接把它添加到结果集即可，注意与「力扣」第 46 题、第 39 题区分</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(curStr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(curStr + <span class="string">&quot;(&quot;</span>, left - <span class="number">1</span>, right, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(curStr + <span class="string">&quot;)&quot;</span>, left, right - <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对比：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        dfs(path, n, n, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path  从根结点到任意结点的路径，全程只使用一份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右括号还有几个可以使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(StringBuilder path, <span class="type">int</span> left, <span class="type">int</span> right, List&lt;String&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// path.toString() 生成了一个新的字符串，相当于做了一次拷贝，这里的做法等同于「力扣」第 46 题、第 39 题</span></span><br><span class="line">            res.add(path.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剪枝（如图，左括号可以使用的个数严格大于右括号可以使用的个数，才剪枝，注意这个细节）</span></span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            dfs(path, left - <span class="number">1</span>, right, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            path.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            dfs(path, left, right - <span class="number">1</span>, res);</span><br><span class="line">            path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>==说明==：</strong></p><p>「回溯算法」强调了在状态空间特别大的时候，只用一份状态变量去搜索所有可能的状态，在搜索到符合条件的解的时候，通常会做</p><p>一个拷贝，这就是为什么经常在递归终止条件的时候，有 <code>res.add(new ArrayList&lt;&gt;(path));</code> 这样的代码。正是因为全程使用一份状</p><p>态变量，因此它就有「恢复现场」和「撤销选择」的需要。</p><h3 id="组合总和（LC39）"><a href="#组合总和（LC39）" class="headerlink" title="组合总和（LC39）"></a>组合总和（LC39）</h3><h4 id="题目详情-1"><a href="#题目详情-1" class="headerlink" title="题目详情"></a>题目详情</h4><p>给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组</p><p>合。</p><p>candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是唯一的。 </p><p>对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p>示例 1：</p><p>输入: candidates = [2,3,6,7], target = 7</p><p>输出: [[7],[2,2,3]]</p><p>示例 2：</p><p>输入: candidates = [2,3,5], target = 8</p><p>输出: [[2,2,2,2],[2,3,3],[3,5]]</p><p>示例 3：</p><p>输入: candidates = [2], target = 1</p><p>输出: []</p><p>示例 4：</p><p>输入: candidates = [1], target = 1</p><p>输出: [[1]]</p><p>示例 5：</p><p>输入: candidates = [1], target = 2</p><p>输出: [[1,1]]</p><p>提示：</p><pre><code>1 &lt;= candidates.length &lt;= 301 &lt;= candidates[i] &lt;= 200candidate 中的每个元素都是独一无二的。1 &lt;= target &lt;= 500</code></pre><h4 id="方法一-4"><a href="#方法一-4" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>对于这类寻找所有可行解的题，我们都可以尝试用「搜索回溯」的方法来解决。</p><p>回到本题，我们定义递归函数 dfs(target, combine, idx) 表示当前在 candidates 数组的第 idx 位，还剩 target 要组合，已经组合的列</p><p>表为 combine。递归的终止条件为 target &lt;= 0 或者 candidates 数组被全部用完。那么在当前的函数中，每次我们可以选择跳过不用</p><p>第 idx 个数，即执行 dfs(target, combine, idx + 1)。也可以选择使用第 idx 个数，即执行 dfs(target - candidates[idx], combine, idx)，</p><p>注意到每个数字可以被无限制重复选取，因此搜索的下标仍为 idx。</p><p>更形象化地说，如果我们将整个搜索过程用一个树来表达，即如下图呈现，每次的搜索都会延伸出两个分叉，直到递归的终止条件，</p><p>这样我们就能不重复且不遗漏地找到所有可行解：</p><p><img src="LeetCode.assets/39_fig1.png" style="zoom:50%;" /></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; combine = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        dfs(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; combine, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(combine));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        dfs(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.add(candidates[idx]);</span><br><span class="line">            dfs(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.remove(combine.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-4"><a href="#方法二-4" class="headerlink" title="方法二"></a>方法二</h4><p><strong>思路：</strong></p><p><img src="LeetCode.assets/1598091943-hZjibJ-file_1598091940241.png" style="zoom:50%;" /></p><pre><code>以 target = 7 为 根结点 ，创建一个分支的时 做减法 ；每一个箭头表示：从父亲结点的数值减去边上的数值，得到孩子结点的数值。边的值就是题目中给出的 candidate 数组的每个元素的值；减到 0 或者负数的时候停止，即：结点 0 和负数结点成为叶子结点；所有从根结点到结点 0的路径（只能从上往下，没有回路）就是题目要找的一个结果。</code></pre><p>这棵树有4 个叶子结点的值 0，对应的路径列表是 [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]，而示例中给出的输出只有 [[7], [2, 2, 3]]。即：题目</p><p>中要求每一个符合要求的解是 不计算顺序 的。下面我们分析为什么会产生重复。</p><p> <em>==针对具体例子分析重复路径产生的原因（难点）：==</em></p><p>产生重复的原因是：在每一个结点，做减法，展开分支的时候，由于题目中说 每一个元素可以重复使用，我们考虑了 所有的 候选</p><p>数，因此出现了重复的列表。</p><p>一种简单的去重方案是借助哈希表的天然去重的功能，但实际操作一下，就会发现并没有那么容易。</p><p>可不可以在搜索的时候就去重呢？答案是可以的。遇到这一类相同元素不计算顺序的问题，我们在搜索的时候就需要 按某种顺序搜</p><p>索。具体的做法是：每一次搜索的时候设置 下一轮搜索的起点 begin，请看下图。</p><p><img src="LeetCode.assets/1.png" style="zoom: 50%;" /></p><p>即：从每一层的第2 个结点开始，都不能再搜索产生同一层结点已经使用过的 <code>candidate</code> 里的元素。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates 候选数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin      搜索起点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len        冗余变量，是 candidates 里的属性，可以不传</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target     每减去一个元素，目标值变小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path       从根结点到叶子结点的路径，是一个栈</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res        结果集列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// target 为负数和 0 的时候不再产生新的孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重点理解这里从 begin 开始搜索的语意</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是 i，这里非常容易弄错</span></span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, res);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 状态重置</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>剪枝：如果 <code>target</code> 减去一个数得到负数，那么减去一个更大的树依然是负数，同样搜索不到结果。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 排序是剪枝的前提</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(candidates, <span class="number">0</span>, len, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> begin, <span class="type">int</span> len, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 由于进入更深层的时候，小于 0 的部分被剪枝，因此递归终止条件值只判断等于 0 的情况</span></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 重点理解这里剪枝，前提是候选数组已经有序，</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, i, len, target - candidates[i], path, res);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合总和②（LC40）"><a href="#组合总和②（LC40）" class="headerlink" title="组合总和②（LC40）"></a>组合总和②（LC40）</h3><h4 id="题目详情-2"><a href="#题目详情-2" class="headerlink" title="题目详情"></a>题目详情</h4><p>给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>candidates 中的每个数字在每个组合中只能使用一次。</p><p>注意：解集不能包含重复的组合。 </p><p>示例 1:</p><p>输入: candidates = [10,1,2,7,6,1,5], target = 8,</p><p>输出:</p><p>[ [1,1,6], [1,2,5], [1,7], [2,6] ]</p><p>示例 2:</p><p>输入: candidates = [2,5,2,1,2], target = 5,</p><p>输出:</p><p>[ [1,2,2], [5] ]</p><p>提示:</p><pre><code>1 &lt;= candidates.length &lt;= 1001 &lt;= candidates[i] &lt;= 501 &lt;= target &lt;= 30</code></pre><h4 id="方法一-5"><a href="#方法一-5" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>在求出组合的过程中就进行去重的操作。我们可以考虑将相同的数放在一起进行处理，也就是说，如果数 x出现了 y 次，</p><p>那么在递归时一次性地处理它们，即分别调用选择 0,1,⋯ ,y次 x的递归函数。这样我们就不会得到重复的组</p><p>合。具体地：</p><pre><code>我们使用一个哈希映射（HashMap）统计数组 candidates中每个数出现的次数。在统计完成之后，我们将结果放入一个列表 freq 中，方便后续的递归使用。列表 freq 的长度即为数组 candidates 中不同数的个数。其中的每一项对应着哈希映射中的一个键值对，即某个数以及它出现的次数。在递归时，对于当前的第 pos 个数，它的值为 freq[pos][0]，出现的次数为 freq[pos][1]，那么我们可以dfs(pos+1,rest−i×freq[pos][0]),即我们选择了这个数 i 次。这里 i 不能大于这个数出现的次数，并且 i×freq[pos][0]也不能大于 rest。同时，我们需要将 i 个 freq[pos][0] 放入列表中。</code></pre><p>这样一来，我们就可以不重复地枚举所有的组合了。</p><p>我们还可以进行什么优化（剪枝）呢？一种比较常用的优化方法是，我们将 freq根据数从小到大排序，这样我们在递</p><p>归时会先选择小的数，再选择大的数。这样做的好处是，当我们递归到 dfs(pos,rest)时，如果 freq[pos][ 0]已经大于 rest，那么后面还没</p><p>有递归到的数也都大于 rest，这就说明不可能再选择若干个和为 rest的数放入列表了。此时，我们就可以直接回溯。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; freq = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;<span class="type">int</span>[]&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; sequence = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : candidates) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> freq.size();</span><br><span class="line">            <span class="keyword">if</span> (freq.isEmpty() || num != freq.get(size - <span class="number">1</span>)[<span class="number">0</span>]) &#123;</span><br><span class="line">                freq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;num, <span class="number">1</span>&#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++freq.get(size - <span class="number">1</span>)[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(<span class="number">0</span>, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> rest)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(sequence));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pos == freq.size() || rest &lt; freq.get(pos)[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dfs(pos + <span class="number">1</span>, rest);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">most</span> <span class="operator">=</span> Math.min(rest / freq.get(pos)[<span class="number">0</span>], freq.get(pos)[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.add(freq.get(pos)[<span class="number">0</span>]);</span><br><span class="line">            dfs(pos + <span class="number">1</span>, rest - i * freq.get(pos)[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= most; ++i) &#123;</span><br><span class="line">            sequence.remove(sequence.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二-5"><a href="#方法二-5" class="headerlink" title="方法二"></a>方法二</h4><p><strong>思路：</strong></p><p>如何去掉重复的集合（重点）</p><p>为了使得解集不包含重复的组合。有以下 2 种方案：</p><pre><code>使用 哈希表 天然的去重功能，但是编码相对复杂；这里我们使用和第 39 题类似的思路：不重复就需要按 顺序 搜索， 在搜索的过程中检测分支是否会出现重复结果 。注意：这里的顺序不仅仅指数组 candidates 有序，还指按照一定顺序搜索结果。</code></pre><p><img src="LeetCode.assets/2.png" style="zoom:50%;" /></p><p><img src="LeetCode.assets/3.png" style="zoom:50%;" /></p><p>由第 39 题我们知道，数组 candidates 有序，也是 深度优先遍历 过程中实现「剪枝」的前提。</p><p>将数组先排序的思路来自于这个问题：去掉一个数组中重复的元素。很容易想到的方案是：先对数组 升序 排序，重复的元素一定不</p><p>是排好序以后相同的连续数组区域的第 1 个元素。也就是说，剪枝发生在：同一层数值相同的结点第 2、3… 个结点，因为数</p><p>值相同的第 1 个结点已经搜索出了包含了这个数值的全部结果，同一层的其它结点，候选数的个数更少，搜索出的结果一定不会比</p><p>第 1 个结点更多，并且是第 1 个结点的子集。（说明：这段文字很拗口，大家可以结合具体例子，在纸上写写画画进行理解。）</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> candidates.length;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关键步骤</span></span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(len);</span><br><span class="line">        dfs(candidates, len, <span class="number">0</span>, target, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> candidates 候选数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len        冗余变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> begin      从候选数组的 begin 位置开始搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target     表示剩余，这个值一开始等于 target，基于题目中说明的&quot;所有数字（包括目标数）都是正整数&quot;这个条件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> path       从根结点到叶子结点的路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> len, <span class="type">int</span> begin, <span class="type">int</span> target, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 大剪枝：减去 candidates[i] 小于 0，减去后面的 candidates[i + 1]、candidates[i + 2] </span></span><br><span class="line">            <span class="comment">//肯定也小于 0，因此用 break</span></span><br><span class="line">            <span class="keyword">if</span> (target - candidates[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 小剪枝：同一层相同数值的结点，从第 2 个开始，候选数更少，结果一定发生重复，因此跳过，用 continue</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; begin &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 因为元素不可以重复使用，这里递归传递下去的是 i + 1 而不是 i</span></span><br><span class="line">            dfs(candidates, len, i + <span class="number">1</span>, target - candidates[i], path, res);</span><br><span class="line"></span><br><span class="line">            path.removeLast();</span><br><span class="line">          </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="全排列（LC46）"><a href="#全排列（LC46）" class="headerlink" title="全排列（LC46）"></a>全排列（LC46）</h3><h4 id="题目详情-3"><a href="#题目详情-3" class="headerlink" title="题目详情"></a>题目详情</h4><p>给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。</p><p>示例 1：</p><p>输入：nums = [1,2,3]</p><p>输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</p><p>示例 2：</p><p>输入：nums = [0,1]</p><p>输出：[[0,1],[1,0]]</p><p>示例 3：</p><p>输入：nums = [1]</p><p>输出：[[1]]</p><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同</code></pre><h4 id="方法一-6"><a href="#方法一-6" class="headerlink" title="方法一"></a>方法一</h4><p><strong>思路：</strong></p><p>这个问题可以看作有 n个排列成一行的空格，我们需要从左往右依此填入题目给定的 n个数，每个数只能使用一次。那么很直</p><p>接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n个空格，在程序中我们可以用</p><p>「回溯法」来模拟这个过程。</p><p>我们定义递归函数 backtrack(first, output) 表示从左往右填到第 first 个位置，当前排列为 output。 </p><p>那么整个递归函数分为两个情况：</p><pre><code>如果 first==n，说明我们已经填完了 n个位置（注意下标从 0开始），找到了一个可行的解，我们将 output 放入答案数组中，递归结束。如果 first&lt;n，我们要考虑这第 first 个位置我们要填哪个数。根据题目要求我们肯定不能填已经填过的数，因此很容易想到的一个处理手段是我们定义一个标记数组 vis[] 来标记已经填过的数，那么在填第 first 个数的时候我们遍历题目给定的 n个数，如果这个数没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个位置，即调用函数 backtrack(first + 1, output)。回溯的时候要撤销这一个位置填的数以及标记，并继续尝试其他没被标记过的数。</code></pre><p>使用标记数组来处理填过的数是一个很直观的思路，但是可不可以去掉这个标记数组呢？毕竟标记数组也<u>增加了我们算法的空间复杂</u></p><p><u>度</u>。</p><p>答案是可以的，我们可以将题目给定的 n 个数的数组 nums 划分成左右两个部分，左边的表示已经填过的数，右</p><p>边表示待填的数，我们在回溯的时候只要动态维护这个数组即可。</p><p>具体来说，假设我们已经填到第 first个位置，那么 nums数组中[0,first−1] 是已填过的数的集合，[][\textit{first},n-1][first,n−1] 是待填的数的集合。我们</p><p>肯定是尝试用 [][\textit{first},n-1][first,n−1] 里的数去填第 first 个数，假设待填的数的下标为 i ，那么填完以后我们将第 i 个数和第 first个数交换，即能</p><p>使得在填第 first+1个数的时候 nums数组的[0,first][0,first] 部分为已填过的数，[][\textit{first}+1,n-1][first+1,n−1] 为待填的数，回溯的时候交换回来即能完成撤销操</p><p>作。</p><p>举个简单的例子，假设我们有 [2, 5, 8, 9, 10] 这 5 个数要填入，已经填到第 3 个位置，已经填了 [8,9] 两个数，那么这个数组目前为 </p><p>[8, 9 | 2, 5, 10] 这样的状态，分隔符区分了左右两个部分。假设这个位置我们要填 10 这个数，为了维护数组，我们将 2 和 10 交换，</p><p>即能使得数组继续保持分隔符左边的数已经填过，右边的待填 [8, 9, 10 | 2, 5] 。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; output = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            output.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        backtrack(n, output, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span> n, List&lt;Integer&gt; output, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> first)</span> &#123;</span><br><span class="line">        <span class="comment">// 所有数都填完了</span></span><br><span class="line">        <span class="keyword">if</span> (first == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(output));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 动态维护数组</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">            <span class="comment">// 继续递归填下一个数</span></span><br><span class="line">            backtrack(n, output, res, first + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 撤销操作</span></span><br><span class="line">            Collections.swap(output, first, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><ul><li><p>时间复杂度：O(n×n!)</p></li><li><p>空间复杂度：O(n)，其中 n 为序列的长度。除答案数组以外，递归函数在递归过程中需要为每一层递归函数分配栈空</p><p>间，所以这里需要额外的空间且该空间取决于递归的深度，这里可知递归调用深度为 O(n)。</p></li></ul><h4 id="方法二-6"><a href="#方法二-6" class="headerlink" title="方法二"></a>方法二</h4><p><strong>思路：</strong></p><p>我们尝试在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。以数组 [1, 2, 3] 的全排列为例。</p><pre><code>先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]，即 1 + [2, 3] 的全排列（注意：递归结构体现在这里）；再写以 2开头的全排列，它们是：[2, 1, 3], [2, 3, 1]，即 2 + [1, 3] 的全排列；最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]，即 3 + [1, 2] 的全排列。</code></pre><p>总结搜索的方法：按顺序枚举每一位可能出现的情况，已经选择的数字在 当前 要选择的数字中不能出现。按照这种策略搜索就能够</p><p>做到 不重不漏。这样的思路，可以用一个树形结构表示。</p><p>看到这里的朋友，建议先尝试自己画出「全排列」问题的树形结构</p><p><img src="LeetCode.assets/0bf18f9b86a2542d1f6aa8db6cc45475fce5aa329a07ca02a9357c2ead81eec1-image.png" style="zoom:50%;" /></p><p><u>设计状态变量</u></p><pre><code>首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即：在已经选择了一些数的前提下，在剩下的还没有选择的数中，依次选择一个数，这显然是一个 递归 结构；递归的终止条件是： 一个排列中的数字已经选够了 ，因此我们需要一个变量来表示当前程序递归到第几层，我们把这个变量叫做 depth，或者命名为 index ，表示当前要确定的是某个全排列中下标为 index 的那个数是多少；布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1) 的时间复杂度判断这个数是否被选择过，这是一种「以空间换时间」的思想。</code></pre><p>这些变量称为「状态变量」，它们表示了在求解一个问题的时候所处的阶段。需要根据问题的场景设计合适的状态变量。</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 使用一个动态数组保存所有可能的全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[len];</span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(len);</span><br><span class="line"></span><br><span class="line">        dfs(nums, len, <span class="number">0</span>, path, used, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> len, <span class="type">int</span> depth,</span></span><br><span class="line"><span class="params">                     Deque&lt;Integer&gt; path, <span class="type">boolean</span>[] used,</span></span><br><span class="line"><span class="params">                     List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (depth == len) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">                path.addLast(nums[i]);</span><br><span class="line">                used[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">              </span><br><span class="line">                dfs(nums, len, depth + <span class="number">1</span>, path, used, res);</span><br><span class="line"></span><br><span class="line">                used[i] = <span class="literal">false</span>;</span><br><span class="line">                path.removeLast();</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="全排列②（LC47）"><a href="#全排列②（LC47）" class="headerlink" title="全排列②（LC47）"></a>全排列②（LC47）</h3><h4 id="题目详情-4"><a href="#题目详情-4" class="headerlink" title="题目详情"></a>题目详情</h4><p>给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。</p><p>示例 1：</p><p>输入：nums = [1,1,2]</p><p>输出：</p><p>[[1,1,2],  [1,2,1], [2,1,1]]</p><p>示例 2：</p><p>输入：nums = [1,2,3]</p><p>输出：[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</p><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 8-10 &lt;= nums[i] &lt;= 10</code></pre><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p><strong>思路：</strong></p><p>解决重复问题，我们只要设定一个规则，保证在填第 idx 个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择对原数</p><p>组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」，即如下的</p><p>判断条件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个判断条件保证了对于重复数的集合，一定是从左往右逐个填入的。</p><p>假设我们有 3个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证</p><p>了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此</p><p>可以达到去重的目标。</p><p><strong>去重原理：</strong></p><p>要实现去重，可以先将原数据排序，这样重复数字一定是相邻的，我们可以认为相邻重复的数字是有序数字，将其当做整体考虑，填</p><p>入时必须按照原序填入，要保证这一点，只有一种办法：要么都填，要么都不填。</p><p>有两种情况下不需要填写该数字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">① 一种是明确已经填过（used[i]==true）</span><br><span class="line">② 一种是该数字没有填过但属于重复数字，且上一个相邻的重复数字没有填过，相当于把重复数字捆绑为整体（有序）来考虑，要么不填，要填   就一起填（注意填充时位置可以是非连续的）</span><br></pre></td></tr></table></figure><p>那么!vis[i-1] 和 vis[i-1] 到底有什么区别呢？</p><p>!vis[i-1] 就是从左往右检查要填一起填，假设有3个连续的1，加个下标变成1_a,1_b,1_c，那么!vis[i-1] 要求如果要填1_b,1_a就必须已</p><p>经填过，最后顺序一定是1_a,1_b,1_c。</p><p>如果是 vis[i-1] ，要求如果要填1_b，那1_a一定不能被填过，所有最后顺序一定是1_c，1_b，1_a</p><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] vis;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; perm = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backtrack(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="type">int</span> idx, List&lt;Integer&gt; perm)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.length) &#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(perm));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line">            backtrack(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">            perm.remove(idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>补充说明：</strong></p><p><em>1、如果剪枝写的是：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，对于数组 <code>[1, 1’, 1’’, 2]</code>，回溯的过程如下：</p><p><img src="LeetCode.assets/01-16285037809663.png" alt=""></p><p>得到的全排列是：[[1, 1’, 1’’, 2], [1, 1’, 2, 1’’], [1, 2, 1’, 1’’], [2, 1, 1’, 1’’]]。特点是：1、1’、1’’ 出现的顺序只能是 1、1’、1’’。</p><p><em>2、如果剪枝写的是：</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，对于数组 <code>[1, 1’, 1’’, 2]</code>，回溯的过程如下（因为过程稍显繁琐，所以没有画在一张图里）：</p><p>（1）先选第 1 个数字，有 4 种取法。</p><p><img src="LeetCode.assets/02-16285037900474.png" alt=""></p><p>（2）对第 1 步的第 1 个分支，可以继续搜索，但是发现，没有搜索到合适的叶子结点。</p><p><img src="LeetCode.assets/03-16285037941445.png" alt=""></p><p>（3）对第 1 步的第 2 个分支，可以继续搜索，但是同样发现，没有搜索到合适的叶子结点。</p><p><img src="LeetCode.assets/04-16285037978936.png" alt=""></p><p>（4）对第 1 步的第 3 个分支，继续搜索发现搜索到合适的叶子结点。</p><p><img src="LeetCode.assets/05-16285038019637.png" alt=""></p><p>（5）对第 1 步的第 4 个分支，继续搜索发现搜索到合适的叶子结点。</p><p><img src="LeetCode.assets/06.png" alt=""></p><p>因此，used[i - 1] 前面加不加感叹号的区别仅在于保留的是相同元素的顺序索引，还是倒序索引。很明显，顺序索引（即使用 </p><p>!used[i -1] 作为剪枝判定条件得到）的递归树剪枝更彻底，思路也相对较自然。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
